
syntax = "proto2";
import "nanopb.proto";


//Commands


//DigitalWrite
//Toggle
//Delay
//I2C Read/Write
//Firmware update
//Analog output
//Analog input
//Touch sensor
//Pulse counter
//PWM
//Beeper
//Fade

//}
/*
CMD_BEEP =
CMD_BEEP_ON =
CMD_BEEP_OFF =

CMD_HELLO '!'
CMD_START '$'

CMD_KEY_PRESSED 'k'

CMD_LCD_OFF 'o'
CMD_LCD_DIM 'd'
CMD_LCD_ON 'l'
CMD_LCD_TEXT 't'
CMD_LCD_CLEAR 'c'
CMD_LCD_CHAR_SET 'C'
CMD_LCD_CHAR_USE 'U'

CMD_SUCCESS ':'
CMD_ERROR '-'
*/



enum PIN_MODE {
    PM_INPUT_PULLUP = 1;
    PM_INPUT_PULLDOWN = 2;
    PM_OUTPUT = 3;
}

message GPIO_CONFIG {
    required uint32 pin = 1 [(nanopb).int_size = IS_8];
    required PIN_MODE mode = 2;
};

message GPIO_MONITOR {
    required uint32 pin = 1 [(nanopb).int_size = IS_8];
    required uint32 debounce_ms = 2;
}

enum PIN_VALUE {
    PV_HIGH =1;
    PV_LOW = 2;
}

message GPIO_WRITE {
    required uint32 pin = 1 [(nanopb).int_size = IS_8];
    required PIN_VALUE value  = 2;
};

message GPIO_READ {
    required uint32 pin = 1 [(nanopb).int_size = IS_8];
}

message OTA_UPDATE {
    required uint32 chunk = 1;
}

message PWM_CONFIG {
    required uint32 pin =1 [(nanopb).int_size = IS_8];
}

// Max duty is 8192

message PWM_DUTY {
    required uint32 pin =1 [(nanopb).int_size = IS_8];
    required uint32 duty = 2;
}

message PWM_FADE {
    required uint32 pin = 1 [(nanopb).int_size = IS_8];
    required uint32 duty = 2;
    required uint32 fade_ms = 3;
}

message I2C_CONFIG {
    optional uint32 pin_sda = 1 [(nanopb).int_size = IS_8];
    optional uint32 pin_scl = 2 [(nanopb).int_size = IS_8];
}

message I2C_WRITE {
    required uint32 device = 1 [(nanopb).int_size = IS_8];
    required uint32 len = 3 [(nanopb).int_size = IS_8];
}

message I2C_READ {
    required uint32 device = 1 [(nanopb).int_size = IS_8];
    required uint32 address = 2 [(nanopb).int_size = IS_8];
    required uint32 len = 3 [(nanopb).int_size = IS_8];
}

message PING {
    required bool ping = 1;
}
message SYSINFO {
    required bool sysinfo = 1;
}

message SCHEDULE {
    required int32 count = 1;
    required uint32 every_ms = 2;
    optional uint32 after_ms = 3;
}

// Allow a nested command to run using the optional data
message RUN_NESTED {
    required bytes cmd_ptr = 1 [(nanopb).max_size = 8];
    required bytes cmd_len = 2 [(nanopb).max_size = 8];
}

message RPC {
    oneof call {
        GPIO_CONFIG gpio_config = 1;
        GPIO_WRITE gpio_write = 2;
        GPIO_READ gpio_read = 3;
        GPIO_MONITOR gpio_monitor = 4;

        PWM_CONFIG pwm_config = 5;
        PWM_DUTY pwm_duty = 6;
        PWM_FADE pwm_fade = 7;

        PING ping = 8;
        SYSINFO sysinfo = 9;

        I2C_CONFIG i2c_config = 10;
        I2C_WRITE i2c_write = 11;
        I2C_READ i2c_read = 12;

        OTA_UPDATE ota_update = 13;
        RUN_NESTED nested = 14;
    }

    required uint32 msg_id = 200;
    optional SCHEDULE schedule = 201;
    optional bytes data = 202 [(nanopb).max_size = 128];
}

enum RESULT_TYPE {
    RT_UNKNOWN = 1;
    RT_SUCCESS = 2;
    RT_ERROR = 3;
}

message PIN_CHANGE {
    required uint32 pin = 1 [(nanopb).int_size = IS_8];
    required PIN_VALUE value =2;
}

enum STARTUP_REASON {
    SR_UNKNOWN = 1;
    ESP32_POWERON_RESET = 2;
    ESP32_SW_RESET = 3;
    ESP32_OWDT_RESET = 4;
    ESP32_DEEPSLEEP_RESET = 5;
    ESP32_SDIO_RESET = 6;
    ESP32_TG0WDT_SYS_RESET = 7;
    ESP32_TG1WDT_SYS_RESET = 8;
    ESP32_RTCWDT_SYS_RESET = 9;
    ESP32_INTRUSION_RESET = 10;
    ESP32_TGWDT_CPU_RESET = 11;
    ESP32_SW_CPU_RESET = 12;
    ESP32_RTCWDT_CPU_RESET = 13;
    ESP32_EXT_CPU_RESET = 14;
    ESP32_RTCWDT_BROWN_OUT_RESET = 15;
    ESP32_RTCWDT_RTC_RESET = 16;
}

message RPC_RESULT {
    required RESULT_TYPE result = 1;
    optional PIN_VALUE pin_value = 2;
    required uint32 msg_id = 200;
}

message FROM_MICRO {

    oneof msg {
        RPC_RESULT result = 1;
        PIN_CHANGE pin_change = 2;
        STARTUP_REASON startup = 3;
    }

    oneof data {
        bytes raw = 200 [(nanopb).max_size = 64];
        int32 schedules_remaining = 201;

    }
}
