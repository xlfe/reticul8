
syntax = "proto2";
import "nanopb.proto";


//Commands


//DigitalWrite
//Toggle
//Delay
//I2C Read/Write
//Firmware update
//Analog output
//Analog input
//Touch sensor
//Pulse counter
//PWM
//Beeper
//Fade

//}
/*
CMD_BEEP =
CMD_BEEP_ON =
CMD_BEEP_OFF =

CMD_HELLO '!'
CMD_START '$'

CMD_KEY_PRESSED 'k'

CMD_LCD_OFF 'o'
CMD_LCD_DIM 'd'
CMD_LCD_ON 'l'
CMD_LCD_TEXT 't'
CMD_LCD_CLEAR 'c'
CMD_LCD_CHAR_SET 'C'
CMD_LCD_CHAR_USE 'U'

CMD_SUCCESS ':'
CMD_ERROR '-'
*/



enum PinMode {
    INPUT_PULLUP = 1;
    INPUT_PULLDOWN = 2;
    OUTPUT = 3;
}

message GPIO_CONFIG {
    required uint32 pin = 1;
    required PinMode mode = 2;
};

message GPIO_MONITOR {
    required uint32 pin = 1;
    required uint32 debounce_ms = 2;
}

enum PinValue {
    HIGH =1;
    LOW = 2;
}

message GPIO_WRITE {
    required uint32 pin = 1;
    required PinValue value  = 2;
};

message GPIO_READ {
    required uint32 pin = 1;
}


message OTA_UPDATE {
    required string uri =1 [(nanopb).max_size = 200];
}

message PWM_CONFIG {
    required uint32 pin =1;
}

message PWM_DUTY {
    required uint32 pin =1;
    required uint32 duty = 2;
}

message PWM_FADE {
    required uint32 pin = 1;
    required uint32 duty = 2;
    required uint32 fade_ms = 3;

}

message I2C_CONFIG {
    optional uint32 pin_sda = 1;
    optional uint32 pin_scl = 2;
}

message I2C_WRITE {
    required uint32 device = 1;
    required bytes data = 2 [(nanopb).max_size = 32];
    required uint32 len = 3;
}

message I2C_READ {
    required uint32 device = 1;
    required uint32 address = 2;
    required uint32 len = 3;
}

message PING {}
message SYSINFO {}

message SCHEDULE {
    required uint32 run_count = 1;
    required uint32 run_every_ms = 2;
    optional uint32 start_after_ms = 3;
}


message RPC {
    oneof call {
        GPIO_CONFIG gpio_config = 1;
        GPIO_WRITE gpio_write = 2;
        GPIO_READ gpio_read = 3;
        GPIO_MONITOR gpio_monitor = 4;

        PWM_CONFIG pwm_config = 5;
        PWM_DUTY pwm_duty = 6;
        PWM_FADE pwm_fade = 7;

        PING ping = 8;
        SYSINFO sysinfo = 9;

        I2C_CONFIG i2c_config = 10;
        I2C_WRITE i2c_write = 11;
        I2C_READ i2c_read = 12;

        OTA_UPDATE ota_update = 100;
    }
    required uint32 msg_id = 200;
    optional SCHEDULE schedule = 201;
}

enum ResultType {
    RT_UNKNOWN = 1;
    RT_SUCCESS = 2;
    RT_ERROR = 3;
}

enum ResultValue {
    PIN_HIGH = 1;
    PIN_LOW = 2;
    SYS_TYPE_ESP32 = 3;
    SYS_TYPE_GENERIC = 4;
}

message CALL_REPLY
{
    required ResultType result = 1;
    optional ResultValue value = 2;
    optional bytes i2c_read_bytes = 3 [(nanopb).max_size = 32];
    required uint32 msg_id = 200;

}

message PIN_CHANGE {
    required uint32 pin =1;
    required PinValue value =2;
}

message EVENT
{
    oneof event {
        PIN_CHANGE pin_change = 1;
    }
}